   1               		.file	"USI_TWI_Master.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 104               	.global	USI_TWI_Master_Initialise
 106               	USI_TWI_Master_Initialise:
 107               		.stabd	46,0,0
   1:USI_TWI_Master.c **** /*****************************************************************************
   2:USI_TWI_Master.c **** *
   3:USI_TWI_Master.c **** * Atmel Corporation
   4:USI_TWI_Master.c **** *
   5:USI_TWI_Master.c **** * File              : USI_TWI_Master.c
   6:USI_TWI_Master.c **** * Compiler          : AVRGCC Toolchain version 3.4.2
   7:USI_TWI_Master.c **** * Revision          : $Revision: 992 $
   8:USI_TWI_Master.c **** * Date              : $Date: 2013-11-07 $
   9:USI_TWI_Master.c **** * Updated by        : $Author: Atmel $
  10:USI_TWI_Master.c **** *
  11:USI_TWI_Master.c **** * Support mail      : avr@atmel.com
  12:USI_TWI_Master.c **** *
  13:USI_TWI_Master.c **** * Supported devices : All device with USI module can be used.
  14:USI_TWI_Master.c **** *                     The example is written for the ATmega169, ATtiny26 and ATtiny2313
  15:USI_TWI_Master.c **** *
  16:USI_TWI_Master.c **** * AppNote           : AVR310 - Using the USI module as a TWI Master
  17:USI_TWI_Master.c **** *
  18:USI_TWI_Master.c **** * Description       : This is an implementation of an TWI master using
  19:USI_TWI_Master.c **** *                     the USI module as basis. The implementation assumes the AVR to
  20:USI_TWI_Master.c **** *                     be the only TWI master in the system and can therefore not be
  21:USI_TWI_Master.c **** *                     used in a multi-master system.
  22:USI_TWI_Master.c **** * Usage             : Initialize the USI module by calling the USI_TWI_Master_Initialise() 
  23:USI_TWI_Master.c **** *                     function. Hence messages/data are transceived on the bus using
  24:USI_TWI_Master.c **** *                     the USI_TWI_Transceive() function. The transceive function 
  25:USI_TWI_Master.c **** *                     returns a status byte, which can be used to evaluate the 
  26:USI_TWI_Master.c **** *                     success of the transmission.
  27:USI_TWI_Master.c **** *
  28:USI_TWI_Master.c **** ****************************************************************************/
  29:USI_TWI_Master.c **** #include <avr/io.h>
  30:USI_TWI_Master.c **** #include "USI_TWI_Master.h"
  31:USI_TWI_Master.c **** #include <util/delay.h>
  32:USI_TWI_Master.c **** 
  33:USI_TWI_Master.c **** unsigned char USI_TWI_Master_Transfer( unsigned char );
  34:USI_TWI_Master.c **** unsigned char USI_TWI_Master_Stop( void );
  35:USI_TWI_Master.c **** 
  36:USI_TWI_Master.c **** union  USI_TWI_state
  37:USI_TWI_Master.c **** {
  38:USI_TWI_Master.c ****   unsigned char errorState;         // Can reuse the TWI_state for error states due to that it will
  39:USI_TWI_Master.c ****   struct
  40:USI_TWI_Master.c ****   {
  41:USI_TWI_Master.c ****     unsigned char addressMode         : 1;
  42:USI_TWI_Master.c ****     unsigned char masterWriteDataMode : 1;
  43:USI_TWI_Master.c ****     unsigned char unused              : 6;
  44:USI_TWI_Master.c ****   }; 
  45:USI_TWI_Master.c **** }   USI_TWI_state;
  46:USI_TWI_Master.c **** 
  47:USI_TWI_Master.c **** /*---------------------------------------------------------------
  48:USI_TWI_Master.c ****  USI TWI single master initialization function
  49:USI_TWI_Master.c **** ---------------------------------------------------------------*/
  50:USI_TWI_Master.c **** void USI_TWI_Master_Initialise( void )
  51:USI_TWI_Master.c **** {
 109               	.LM0:
 110               	.LFBB1:
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 0 */
 114               	.L__stack_usage = 0
  52:USI_TWI_Master.c ****   PORT_USI |= (1<<PIN_USI_SDA);           // Enable pullup on SDA, to set high as released state.
 116               	.LM1:
 117 0000 C09A      		sbi 0x18,0
  53:USI_TWI_Master.c ****   PORT_USI |= (1<<PIN_USI_SCL);           // Enable pullup on SCL, to set high as released state.
 119               	.LM2:
 120 0002 C29A      		sbi 0x18,2
  54:USI_TWI_Master.c ****   
  55:USI_TWI_Master.c ****   DDR_USI  |= (1<<PIN_USI_SCL);           // Enable SCL as output.
 122               	.LM3:
 123 0004 BA9A      		sbi 0x17,2
  56:USI_TWI_Master.c ****   DDR_USI  |= (1<<PIN_USI_SDA);           // Enable SDA as output.
 125               	.LM4:
 126 0006 B89A      		sbi 0x17,0
  57:USI_TWI_Master.c ****   
  58:USI_TWI_Master.c ****   USIDR    =  0xFF;                       // Preload dataregister with "released level" data.
 128               	.LM5:
 129 0008 8FEF      		ldi r24,lo8(-1)
 130 000a 8FB9      		out 0xf,r24
  59:USI_TWI_Master.c ****   USICR    =  (0<<USISIE)|(0<<USIOIE)|                            // Disable Interrupts.
 132               	.LM6:
 133 000c 8AE2      		ldi r24,lo8(42)
 134 000e 8DB9      		out 0xd,r24
  60:USI_TWI_Master.c ****               (1<<USIWM1)|(0<<USIWM0)|                            // Set USI in Two-wire mode.
  61:USI_TWI_Master.c ****               (1<<USICS1)|(0<<USICS0)|(1<<USICLK)|                // Software stobe as counter cloc
  62:USI_TWI_Master.c ****               (0<<USITC);
  63:USI_TWI_Master.c ****   USISR   =   (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)|      // Clear flags,
 136               	.LM7:
 137 0010 80EF      		ldi r24,lo8(-16)
 138 0012 8EB9      		out 0xe,r24
 139 0014 0895      		ret
 141               	.Lscope1:
 143               		.stabd	78,0,0
 145               	.global	USI_TWI_Get_State_Info
 147               	USI_TWI_Get_State_Info:
 148               		.stabd	46,0,0
  64:USI_TWI_Master.c ****               (0x0<<USICNT0);                                     // and reset counter.
  65:USI_TWI_Master.c **** }
  66:USI_TWI_Master.c **** 
  67:USI_TWI_Master.c **** /*---------------------------------------------------------------
  68:USI_TWI_Master.c **** Use this function to get hold of the error message from the last transmission
  69:USI_TWI_Master.c **** ---------------------------------------------------------------*/
  70:USI_TWI_Master.c **** unsigned char USI_TWI_Get_State_Info( void )
  71:USI_TWI_Master.c **** {
 150               	.LM8:
 151               	.LFBB2:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
  72:USI_TWI_Master.c ****   return ( USI_TWI_state.errorState );                            // Return error state.
  73:USI_TWI_Master.c **** }
 157               	.LM9:
 158 0016 8091 0000 		lds r24,USI_TWI_state
 159 001a 0895      		ret
 161               	.Lscope2:
 163               		.stabd	78,0,0
 166               	.global	USI_TWI_Master_Transfer
 168               	USI_TWI_Master_Transfer:
 169               		.stabd	46,0,0
  74:USI_TWI_Master.c **** 
  75:USI_TWI_Master.c **** /*---------------------------------------------------------------
  76:USI_TWI_Master.c ****  USI Transmit and receive function. LSB of first byte in data 
  77:USI_TWI_Master.c ****  indicates if a read or write cycles is performed. If set a read
  78:USI_TWI_Master.c ****  operation is performed.
  79:USI_TWI_Master.c **** 
  80:USI_TWI_Master.c ****  Function generates (Repeated) Start Condition, sends address and
  81:USI_TWI_Master.c ****  R/W, Reads/Writes Data, and verifies/sends ACK.
  82:USI_TWI_Master.c ****  
  83:USI_TWI_Master.c ****  Success or error code is returned. Error codes are defined in 
  84:USI_TWI_Master.c ****  USI_TWI_Master.h
  85:USI_TWI_Master.c **** ---------------------------------------------------------------*/
  86:USI_TWI_Master.c **** unsigned char USI_TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize)
  87:USI_TWI_Master.c **** {
  88:USI_TWI_Master.c ****   unsigned char tempUSISR_8bit = (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)|      // Prepare reg
  89:USI_TWI_Master.c ****                                  (0x0<<USICNT0);                                     // set USI to 
  90:USI_TWI_Master.c ****   unsigned char tempUSISR_1bit = (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)|      // Prepare reg
  91:USI_TWI_Master.c ****                                  (0xE<<USICNT0);                                     // set USI to 
  92:USI_TWI_Master.c **** 
  93:USI_TWI_Master.c ****   USI_TWI_state.errorState = 0;
  94:USI_TWI_Master.c ****   USI_TWI_state.addressMode = TRUE;
  95:USI_TWI_Master.c **** 
  96:USI_TWI_Master.c **** #ifdef PARAM_VERIFICATION
  97:USI_TWI_Master.c ****   if(msg > (unsigned char*)RAMEND)                 // Test if address is outside SRAM space
  98:USI_TWI_Master.c ****   {
  99:USI_TWI_Master.c ****     USI_TWI_state.errorState = USI_TWI_DATA_OUT_OF_BOUND;
 100:USI_TWI_Master.c ****     return (FALSE);
 101:USI_TWI_Master.c ****   }
 102:USI_TWI_Master.c ****   if(msgSize <= 1)                                 // Test if the transmission buffer is empty
 103:USI_TWI_Master.c ****   {
 104:USI_TWI_Master.c ****     USI_TWI_state.errorState = USI_TWI_NO_DATA;
 105:USI_TWI_Master.c ****     return (FALSE);
 106:USI_TWI_Master.c ****   }
 107:USI_TWI_Master.c **** #endif
 108:USI_TWI_Master.c **** 
 109:USI_TWI_Master.c **** #ifdef NOISE_TESTING                                // Test if any unexpected conditions have arriv
 110:USI_TWI_Master.c ****   if( USISR & (1<<USISIF) )
 111:USI_TWI_Master.c ****   {
 112:USI_TWI_Master.c ****     USI_TWI_state.errorState = USI_TWI_UE_START_CON;
 113:USI_TWI_Master.c ****     return (FALSE);
 114:USI_TWI_Master.c ****   }
 115:USI_TWI_Master.c ****   if( USISR & (1<<USIPF) )
 116:USI_TWI_Master.c ****   {
 117:USI_TWI_Master.c ****     USI_TWI_state.errorState = USI_TWI_UE_STOP_CON;
 118:USI_TWI_Master.c ****     return (FALSE);
 119:USI_TWI_Master.c ****   }
 120:USI_TWI_Master.c ****   if( USISR & (1<<USIDC) )
 121:USI_TWI_Master.c ****   {
 122:USI_TWI_Master.c ****     USI_TWI_state.errorState = USI_TWI_UE_DATA_COL;
 123:USI_TWI_Master.c ****     return (FALSE);
 124:USI_TWI_Master.c ****   }
 125:USI_TWI_Master.c **** #endif
 126:USI_TWI_Master.c **** 
 127:USI_TWI_Master.c ****   if ( !(*msg & (1<<TWI_READ_BIT)) )                // The LSB in the address byte determines if is
 128:USI_TWI_Master.c ****   {
 129:USI_TWI_Master.c ****     USI_TWI_state.masterWriteDataMode = TRUE;
 130:USI_TWI_Master.c ****   }
 131:USI_TWI_Master.c **** 
 132:USI_TWI_Master.c **** /* Release SCL to ensure that (repeated) Start can be performed */
 133:USI_TWI_Master.c ****   PORT_USI |= (1<<PIN_USI_SCL);                     // Release SCL.
 134:USI_TWI_Master.c ****   while( !(PIN_USI & (1<<PIN_USI_SCL)) );          // Verify that SCL becomes high.
 135:USI_TWI_Master.c **** #ifdef TWI_FAST_MODE
 136:USI_TWI_Master.c ****   _delay_us( T4_TWI/4 );                         // Delay for T4TWI if TWI_FAST_MODE
 137:USI_TWI_Master.c **** #else
 138:USI_TWI_Master.c ****   _delay_us( T2_TWI/4 );                         // Delay for T2TWI if TWI_STANDARD_MODE
 139:USI_TWI_Master.c **** #endif
 140:USI_TWI_Master.c **** 
 141:USI_TWI_Master.c **** /* Generate Start Condition */
 142:USI_TWI_Master.c ****   PORT_USI &= ~(1<<PIN_USI_SDA);                    // Force SDA LOW.
 143:USI_TWI_Master.c ****   _delay_us( T4_TWI/4 );                         
 144:USI_TWI_Master.c ****   PORT_USI &= ~(1<<PIN_USI_SCL);                    // Pull SCL LOW.
 145:USI_TWI_Master.c ****   PORT_USI |= (1<<PIN_USI_SDA);                     // Release SDA.
 146:USI_TWI_Master.c **** 
 147:USI_TWI_Master.c **** #ifdef SIGNAL_VERIFY
 148:USI_TWI_Master.c ****   if( !(USISR & (1<<USISIF)) )
 149:USI_TWI_Master.c ****   {
 150:USI_TWI_Master.c ****     USI_TWI_state.errorState = USI_TWI_MISSING_START_CON;  
 151:USI_TWI_Master.c ****     return (FALSE);
 152:USI_TWI_Master.c ****   }
 153:USI_TWI_Master.c **** #endif
 154:USI_TWI_Master.c **** 
 155:USI_TWI_Master.c **** /*Write address and Read/Write data */
 156:USI_TWI_Master.c ****   do
 157:USI_TWI_Master.c ****   {
 158:USI_TWI_Master.c ****     /* If masterWrite cycle (or inital address tranmission)*/
 159:USI_TWI_Master.c ****     if (USI_TWI_state.addressMode || USI_TWI_state.masterWriteDataMode)
 160:USI_TWI_Master.c ****     {
 161:USI_TWI_Master.c ****       /* Write a byte */
 162:USI_TWI_Master.c ****       PORT_USI &= ~(1<<PIN_USI_SCL);                // Pull SCL LOW.
 163:USI_TWI_Master.c ****       USIDR     = *(msg++);                        // Setup data.
 164:USI_TWI_Master.c ****       USI_TWI_Master_Transfer( tempUSISR_8bit );    // Send 8 bits on bus.
 165:USI_TWI_Master.c ****       
 166:USI_TWI_Master.c ****       /* Clock and verify (N)ACK from slave */
 167:USI_TWI_Master.c ****       DDR_USI  &= ~(1<<PIN_USI_SDA);                // Enable SDA as input.
 168:USI_TWI_Master.c ****       if( USI_TWI_Master_Transfer( tempUSISR_1bit ) & (1<<TWI_NACK_BIT) ) 
 169:USI_TWI_Master.c ****       {
 170:USI_TWI_Master.c ****         if ( USI_TWI_state.addressMode )
 171:USI_TWI_Master.c ****           USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 172:USI_TWI_Master.c ****         else
 173:USI_TWI_Master.c ****           USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
 174:USI_TWI_Master.c ****         return (FALSE);
 175:USI_TWI_Master.c ****       }
 176:USI_TWI_Master.c ****       USI_TWI_state.addressMode = FALSE;            // Only perform address transmission once.
 177:USI_TWI_Master.c ****     }
 178:USI_TWI_Master.c ****     /* Else masterRead cycle*/
 179:USI_TWI_Master.c ****     else
 180:USI_TWI_Master.c ****     {
 181:USI_TWI_Master.c ****       /* Read a data byte */
 182:USI_TWI_Master.c ****       DDR_USI   &= ~(1<<PIN_USI_SDA);               // Enable SDA as input.
 183:USI_TWI_Master.c ****       *(msg++)  = USI_TWI_Master_Transfer( tempUSISR_8bit );
 184:USI_TWI_Master.c **** 
 185:USI_TWI_Master.c ****       /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
 186:USI_TWI_Master.c ****       if( msgSize == 1)                            // If transmission of last byte was performed.
 187:USI_TWI_Master.c ****       {
 188:USI_TWI_Master.c ****         USIDR = 0xFF;                              // Load NACK to confirm End Of Transmission.
 189:USI_TWI_Master.c ****       }
 190:USI_TWI_Master.c ****       else
 191:USI_TWI_Master.c ****       {
 192:USI_TWI_Master.c ****         USIDR = 0x00;                              // Load ACK. Set data register bit 7 (output for
 193:USI_TWI_Master.c ****       }
 194:USI_TWI_Master.c ****       USI_TWI_Master_Transfer( tempUSISR_1bit );   // Generate ACK/NACK.
 195:USI_TWI_Master.c ****     }
 196:USI_TWI_Master.c ****   }while( --msgSize) ;                             // Until all data sent/received.
 197:USI_TWI_Master.c ****   
 198:USI_TWI_Master.c ****   USI_TWI_Master_Stop();                           // Send a STOP condition on the TWI bus.
 199:USI_TWI_Master.c **** 
 200:USI_TWI_Master.c **** /* Transmission successfully completed*/
 201:USI_TWI_Master.c ****   return (TRUE);
 202:USI_TWI_Master.c **** }
 203:USI_TWI_Master.c **** 
 204:USI_TWI_Master.c **** /*---------------------------------------------------------------
 205:USI_TWI_Master.c ****  Core function for shifting data in and out from the USI.
 206:USI_TWI_Master.c ****  Data to be sent has to be placed into the USIDR prior to calling
 207:USI_TWI_Master.c ****  this function. Data read, will be return'ed from the function.
 208:USI_TWI_Master.c **** ---------------------------------------------------------------*/
 209:USI_TWI_Master.c **** unsigned char USI_TWI_Master_Transfer( unsigned char temp )
 210:USI_TWI_Master.c **** {
 171               	.LM10:
 172               	.LFBB3:
 173               	/* prologue: function */
 174               	/* frame size = 0 */
 175               	/* stack size = 0 */
 176               	.L__stack_usage = 0
 211:USI_TWI_Master.c ****   USISR = temp;                                     // Set USISR according to temp.
 178               	.LM11:
 179 001c 8EB9      		out 0xe,r24
 212:USI_TWI_Master.c ****                                                     // Prepare clocking.
 213:USI_TWI_Master.c ****   temp  =  (0<<USISIE)|(0<<USIOIE)|                 // Interrupts disabled
 214:USI_TWI_Master.c ****            (1<<USIWM1)|(0<<USIWM0)|                 // Set USI in Two-wire mode.
 215:USI_TWI_Master.c ****            (1<<USICS1)|(0<<USICS0)|(1<<USICLK)|     // Software clock strobe as source.
 216:USI_TWI_Master.c ****            (1<<USITC);                              // Toggle Clock Port.
 217:USI_TWI_Master.c ****   do
 218:USI_TWI_Master.c ****   {
 219:USI_TWI_Master.c ****     _delay_us( T2_TWI/4 );              
 220:USI_TWI_Master.c ****     USICR = temp;                          // Generate positve SCL edge.
 181               	.LM12:
 182 001e 8BE2      		ldi r24,lo8(43)
 183               	.L7:
 184               	.LBB16:
 185               	.LBB17:
 187               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 189               	.LM13:
 190 0020 92E0      		ldi r25,lo8(2)
 191 0022 9A95      		1: dec r25
 192 0024 01F4      		brne 1b
 193               	.LBE17:
 194               	.LBE16:
 196               	.Ltext2:
 198               	.LM14:
 199 0026 8DB9      		out 0xd,r24
 200               	.L5:
 221:USI_TWI_Master.c ****     while( !(PIN_USI & (1<<PIN_USI_SCL)) );// Wait for SCL to go high.
 202               	.LM15:
 203 0028 B29B      		sbis 0x16,2
 204 002a 00C0      		rjmp .L5
 205               	.LBB18:
 206               	.LBB19:
 208               	.Ltext3:
 210               	.LM16:
 211 002c 00C0      		rjmp .
 212 002e 0000      		nop
 213               	.LBE19:
 214               	.LBE18:
 216               	.Ltext4:
 222:USI_TWI_Master.c ****     _delay_us( T4_TWI/4 );              
 223:USI_TWI_Master.c ****     USICR = temp;                          // Generate negative SCL edge.
 218               	.LM17:
 219 0030 8DB9      		out 0xd,r24
 224:USI_TWI_Master.c ****   }while( !(USISR & (1<<USIOIF)) );        // Check for transfer complete.
 221               	.LM18:
 222 0032 769B      		sbis 0xe,6
 223 0034 00C0      		rjmp .L7
 224               	.LBB20:
 225               	.LBB21:
 227               	.Ltext5:
 229               	.LM19:
 230 0036 82E0      		ldi r24,lo8(2)
 231 0038 8A95      		1: dec r24
 232 003a 01F4      		brne 1b
 233               	.LBE21:
 234               	.LBE20:
 236               	.Ltext6:
 225:USI_TWI_Master.c ****   
 226:USI_TWI_Master.c ****   _delay_us( T2_TWI/4 );                
 227:USI_TWI_Master.c ****   temp  = USIDR;                           // Read out data.
 238               	.LM20:
 239 003c 8FB1      		in r24,0xf
 228:USI_TWI_Master.c ****   USIDR = 0xFF;                            // Release SDA.
 241               	.LM21:
 242 003e 9FEF      		ldi r25,lo8(-1)
 243 0040 9FB9      		out 0xf,r25
 229:USI_TWI_Master.c ****   DDR_USI |= (1<<PIN_USI_SDA);             // Enable SDA as output.
 245               	.LM22:
 246 0042 B89A      		sbi 0x17,0
 230:USI_TWI_Master.c **** 
 231:USI_TWI_Master.c ****   return temp;                             // Return the data from the USIDR
 232:USI_TWI_Master.c **** }
 248               	.LM23:
 249 0044 0895      		ret
 251               	.Lscope3:
 253               		.stabd	78,0,0
 255               	.global	USI_TWI_Master_Stop
 257               	USI_TWI_Master_Stop:
 258               		.stabd	46,0,0
 233:USI_TWI_Master.c **** 
 234:USI_TWI_Master.c **** /*---------------------------------------------------------------
 235:USI_TWI_Master.c ****  Function for generating a TWI Stop Condition. Used to release 
 236:USI_TWI_Master.c ****  the TWI bus.
 237:USI_TWI_Master.c **** ---------------------------------------------------------------*/
 238:USI_TWI_Master.c **** unsigned char USI_TWI_Master_Stop( void )
 239:USI_TWI_Master.c **** {
 260               	.LM24:
 261               	.LFBB4:
 262               	/* prologue: function */
 263               	/* frame size = 0 */
 264               	/* stack size = 0 */
 265               	.L__stack_usage = 0
 240:USI_TWI_Master.c ****   PORT_USI &= ~(1<<PIN_USI_SDA);           // Pull SDA low.
 267               	.LM25:
 268 0046 C098      		cbi 0x18,0
 241:USI_TWI_Master.c ****   PORT_USI |= (1<<PIN_USI_SCL);            // Release SCL.
 270               	.LM26:
 271 0048 C29A      		sbi 0x18,2
 272               	.L11:
 242:USI_TWI_Master.c ****   while( !(PIN_USI & (1<<PIN_USI_SCL)) );  // Wait for SCL to go high.
 274               	.LM27:
 275 004a B29B      		sbis 0x16,2
 276 004c 00C0      		rjmp .L11
 277               	.LBB22:
 278               	.LBB23:
 280               	.Ltext7:
 282               	.LM28:
 283 004e 00C0      		rjmp .
 284 0050 0000      		nop
 285               	.LBE23:
 286               	.LBE22:
 288               	.Ltext8:
 243:USI_TWI_Master.c ****   _delay_us( T4_TWI/4 );               
 244:USI_TWI_Master.c ****   PORT_USI |= (1<<PIN_USI_SDA);            // Release SDA.
 290               	.LM29:
 291 0052 C09A      		sbi 0x18,0
 292               	.LBB24:
 293               	.LBB25:
 295               	.Ltext9:
 297               	.LM30:
 298 0054 82E0      		ldi r24,lo8(2)
 299 0056 8A95      		1: dec r24
 300 0058 01F4      		brne 1b
 301               	.LBE25:
 302               	.LBE24:
 304               	.Ltext10:
 245:USI_TWI_Master.c ****   _delay_us( T2_TWI/4 );                
 246:USI_TWI_Master.c ****   
 247:USI_TWI_Master.c **** #ifdef SIGNAL_VERIFY
 248:USI_TWI_Master.c ****   if( !(USISR & (1<<USIPF)) )
 249:USI_TWI_Master.c ****   {
 250:USI_TWI_Master.c ****     USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;    
 251:USI_TWI_Master.c ****     return (FALSE);
 252:USI_TWI_Master.c ****   }
 253:USI_TWI_Master.c **** #endif
 254:USI_TWI_Master.c **** 
 255:USI_TWI_Master.c ****   return (TRUE);
 256:USI_TWI_Master.c **** }
 306               	.LM31:
 307 005a 81E0      		ldi r24,lo8(1)
 308 005c 0895      		ret
 310               	.Lscope4:
 312               		.stabd	78,0,0
 316               	.global	USI_TWI_Start_Transceiver_With_Data
 318               	USI_TWI_Start_Transceiver_With_Data:
 319               		.stabd	46,0,0
  87:USI_TWI_Master.c ****   unsigned char tempUSISR_8bit = (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)|      // Prepare reg
 321               	.LM32:
 322               	.LFBB5:
 323 005e 0F93      		push r16
 324 0060 1F93      		push r17
 325 0062 CF93      		push r28
 326 0064 DF93      		push r29
 327               	/* prologue: function */
 328               	/* frame size = 0 */
 329               	/* stack size = 4 */
 330               	.L__stack_usage = 4
 331 0066 162F      		mov r17,r22
  94:USI_TWI_Master.c **** 
 333               	.LM33:
 334 0068 21E0      		ldi r18,lo8(1)
 335 006a 2093 0000 		sts USI_TWI_state,r18
 127:USI_TWI_Master.c ****   {
 337               	.LM34:
 338 006e FC01      		movw r30,r24
 339 0070 2081      		ld r18,Z
 340 0072 20FD      		sbrc r18,0
 341 0074 00C0      		rjmp .L13
 129:USI_TWI_Master.c ****   }
 343               	.LM35:
 344 0076 23E0      		ldi r18,lo8(3)
 345 0078 2093 0000 		sts USI_TWI_state,r18
 346               	.L13:
 133:USI_TWI_Master.c ****   while( !(PIN_USI & (1<<PIN_USI_SCL)) );          // Verify that SCL becomes high.
 348               	.LM36:
 349 007c C29A      		sbi 0x18,2
 350               	.L15:
 134:USI_TWI_Master.c **** #ifdef TWI_FAST_MODE
 352               	.LM37:
 353 007e B29B      		sbis 0x16,2
 354 0080 00C0      		rjmp .L15
 355               	.LBB26:
 356               	.LBB27:
 358               	.Ltext11:
 360               	.LM38:
 361 0082 00C0      		rjmp .
 362 0084 0000      		nop
 363               	.LBE27:
 364               	.LBE26:
 366               	.Ltext12:
 142:USI_TWI_Master.c ****   _delay_us( T4_TWI/4 );                         
 368               	.LM39:
 369 0086 C098      		cbi 0x18,0
 370               	.LBB28:
 371               	.LBB29:
 373               	.Ltext13:
 375               	.LM40:
 376 0088 00C0      		rjmp .
 377 008a 0000      		nop
 378               	.LBE29:
 379               	.LBE28:
 381               	.Ltext14:
 144:USI_TWI_Master.c ****   PORT_USI |= (1<<PIN_USI_SDA);                     // Release SDA.
 383               	.LM41:
 384 008c C298      		cbi 0x18,2
 145:USI_TWI_Master.c **** 
 386               	.LM42:
 387 008e C09A      		sbi 0x18,0
 388 0090 EC01      		movw r28,r24
 188:USI_TWI_Master.c ****       }
 390               	.LM43:
 391 0092 0FEF      		ldi r16,lo8(-1)
 392               	.L24:
 159:USI_TWI_Master.c ****     {
 394               	.LM44:
 395 0094 8091 0000 		lds r24,USI_TWI_state
 396 0098 8370      		andi r24,lo8(3)
 397 009a 01F0      		breq .L16
 162:USI_TWI_Master.c ****       USIDR     = *(msg++);                        // Setup data.
 399               	.LM45:
 400 009c C298      		cbi 0x18,2
 163:USI_TWI_Master.c ****       USI_TWI_Master_Transfer( tempUSISR_8bit );    // Send 8 bits on bus.
 402               	.LM46:
 403 009e 8881      		ld r24,Y
 404 00a0 8FB9      		out 0xf,r24
 164:USI_TWI_Master.c ****       
 406               	.LM47:
 407 00a2 80EF      		ldi r24,lo8(-16)
 408 00a4 00D0      		rcall USI_TWI_Master_Transfer
 167:USI_TWI_Master.c ****       if( USI_TWI_Master_Transfer( tempUSISR_1bit ) & (1<<TWI_NACK_BIT) ) 
 410               	.LM48:
 411 00a6 B898      		cbi 0x17,0
 168:USI_TWI_Master.c ****       {
 413               	.LM49:
 414 00a8 8EEF      		ldi r24,lo8(-2)
 415 00aa 00D0      		rcall USI_TWI_Master_Transfer
 416 00ac 80FF      		sbrs r24,0
 417 00ae 00C0      		rjmp .L17
 170:USI_TWI_Master.c ****           USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 419               	.LM50:
 420 00b0 9091 0000 		lds r25,USI_TWI_state
 421 00b4 892F      		mov r24,r25
 422 00b6 8170      		andi r24,lo8(1)
 423 00b8 90FF      		sbrs r25,0
 424 00ba 00C0      		rjmp .L18
 171:USI_TWI_Master.c ****         else
 426               	.LM51:
 427 00bc 86E0      		ldi r24,lo8(6)
 428 00be 8093 0000 		sts USI_TWI_state,r24
 174:USI_TWI_Master.c ****       }
 430               	.LM52:
 431 00c2 80E0      		ldi r24,0
 432 00c4 00C0      		rjmp .L19
 433               	.L18:
 173:USI_TWI_Master.c ****         return (FALSE);
 435               	.LM53:
 436 00c6 95E0      		ldi r25,lo8(5)
 437 00c8 9093 0000 		sts USI_TWI_state,r25
 438 00cc 00C0      		rjmp .L19
 439               	.L17:
 176:USI_TWI_Master.c ****     }
 441               	.LM54:
 442 00ce 8091 0000 		lds r24,USI_TWI_state
 443 00d2 8E7F      		andi r24,lo8(~(1<<0))
 444 00d4 8093 0000 		sts USI_TWI_state,r24
 445 00d8 00C0      		rjmp .L20
 446               	.L16:
 182:USI_TWI_Master.c ****       *(msg++)  = USI_TWI_Master_Transfer( tempUSISR_8bit );
 448               	.LM55:
 449 00da B898      		cbi 0x17,0
 183:USI_TWI_Master.c **** 
 451               	.LM56:
 452 00dc 80EF      		ldi r24,lo8(-16)
 453 00de 00D0      		rcall USI_TWI_Master_Transfer
 454 00e0 8883      		st Y,r24
 186:USI_TWI_Master.c ****       {
 456               	.LM57:
 457 00e2 1130      		cpi r17,lo8(1)
 458 00e4 01F4      		brne .L21
 188:USI_TWI_Master.c ****       }
 460               	.LM58:
 461 00e6 0FB9      		out 0xf,r16
 462 00e8 00C0      		rjmp .L22
 463               	.L21:
 192:USI_TWI_Master.c ****       }
 465               	.LM59:
 466 00ea 1FB8      		out 0xf,__zero_reg__
 467               	.L22:
 194:USI_TWI_Master.c ****     }
 469               	.LM60:
 470 00ec 8EEF      		ldi r24,lo8(-2)
 471 00ee 00D0      		rcall USI_TWI_Master_Transfer
 472               	.L20:
 196:USI_TWI_Master.c ****   
 474               	.LM61:
 475 00f0 1150      		subi r17,lo8(-(-1))
 476 00f2 2196      		adiw r28,1
 477 00f4 1111      		cpse r17,__zero_reg__
 478 00f6 00C0      		rjmp .L24
 198:USI_TWI_Master.c **** 
 480               	.LM62:
 481 00f8 00D0      		rcall USI_TWI_Master_Stop
 201:USI_TWI_Master.c **** }
 483               	.LM63:
 484 00fa 81E0      		ldi r24,lo8(1)
 485               	.L19:
 486               	/* epilogue start */
 202:USI_TWI_Master.c **** 
 488               	.LM64:
 489 00fc DF91      		pop r29
 490 00fe CF91      		pop r28
 491 0100 1F91      		pop r17
 492 0102 0F91      		pop r16
 493 0104 0895      		ret
 495               	.Lscope5:
 497               		.stabd	78,0,0
 498               		.comm	USI_TWI_state,1,1
 501               	.Letext0:
 502               		.ident	"GCC: (GNU) 4.8.1"
 503               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 USI_TWI_Master.c
     /tmp/cctigoTq.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cctigoTq.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cctigoTq.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cctigoTq.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cctigoTq.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cctigoTq.s:106    .text:0000000000000000 USI_TWI_Master_Initialise
     /tmp/cctigoTq.s:147    .text:0000000000000016 USI_TWI_Get_State_Info
                            *COM*:0000000000000001 USI_TWI_state
     /tmp/cctigoTq.s:168    .text:000000000000001c USI_TWI_Master_Transfer
     /tmp/cctigoTq.s:257    .text:0000000000000046 USI_TWI_Master_Stop
     /tmp/cctigoTq.s:318    .text:000000000000005e USI_TWI_Start_Transceiver_With_Data

UNDEFINED SYMBOLS
__do_clear_bss
